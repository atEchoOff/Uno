<head>
    <link rel="stylesheet" href="{{url_for('static', filename='style/gameRoom.css')}}">
</head>

<div id="card-container">
    <p id="pass">pass</p>
</div>
<div id="player-container"></div>
<div id="table-container">
    <div id="deck-container"></div>
    <div id="current-card-container"></div>
</div>
<div id="opposing-player-container"></div>

<script>
    let myId = {{ id }};
    let numCards = {}; // The number of cards belonging to each player id
    let idToUserName = {}; // Map of server ids to usernames

    let cardContainer = document.getElementById("card-container");
    let currentCardContainer = document.getElementById("current-card-container");
    let playerContainer = document.getElementById("player-container");
    let opposingPlayerContainer = document.getElementById("opposing-player-container");
    let deckContainer = document.getElementById("deck-container");
    let pass = document.getElementById("pass");

    pass.addEventListener("click", () => {
        broadcast("pass");
    });

    // Save some game stats from the server
    let p2_value = 0;
    let p4_value = 0;
    let currUserId = -1;
    let p2_allow_foreign = 0;
    let p4_allow_foreign = 0; // FIXME impliment this

    function getCard(cardName, interactable) {
        // Return an element with specific cardName (image)
        let card = document.createElement("img");
        card.src = "{{url_for('static', filename='UnoCards/CARD_TYPE.png')}}".replace("CARD_TYPE", cardName);
        card.classList.add("uno-card");
        card.name = cardName;
        if (interactable) {
            // If we click the card, try to play it
            card.addEventListener("click", cardPressed);
            card.style.cursor = "pointer";
        }
        return card;
    }

    function cardCompare(card1, card2) {
        if (card1.name.startsWith("w") && card2.name.startsWith("w")) {
            return card1.name < card2.name;
        } else if (card1.name.startsWith("w")) {
            return 1;
        } else if (card2.name.startsWith("w")) {
            return 0;
        } else {
            return card1.name < card2.name;
        }
    }

    function addCard(card) {
        // Insert a card into the card viewer alphabetically
        let curCard = cardContainer.firstChild;
        while (curCard && curCard.name && cardCompare(curCard, card)) {
            curCard = curCard.nextSibling;
        }

        if (curCard) {
            // Our card should go just before this one
            cardContainer.insertBefore(card, curCard);
        } else {
            // We hit the end of the list, or the list was empty. Append to the end
            cardContainer.appendChild(card);
        }
    }

    function startGame() {
        // Tell the server to close the game entry and start
        fetch('{{url_for("start_game", room_name=room_name)}}');
    }

    function cardPressed(e) {
        // "hard-pressed"... Get it?
        // Card was pressed, send off to server
        let cardValue = e.target.name;
        broadcast(cardValue).then((response) => {
            if (response.ok) {
                // Card was played! Remove card from viewer
                e.target.remove();
            } else if (response.status == 418) {
                // Server is waiting for wild color, hand it off
                let color = prompt("What color wild?", "Color (r/y/g/b)");
                broadcast(color);

                // Remove the wild card, we are done with it
                e.target.remove();
            } else {
                // There was a 404! Print it to the consone
                console.log("Error when pressing card: 404");
            }
        })
    }

    function updateOpposingPlayerWindow() {
        // Update the number of cards displayed at the top to the currPlayerId's number of cards
        // Make sure this function only runs under valid conditions
        if (currUserId == -1) {
            return;
        } else if (numCards[currUserId] == -1) {
            return;
        }

        if (opposingPlayerContainer.childElementCount != numCards[currUserId]) {
            opposingPlayerContainer.innerHTML = "";
            for (var i = 0; i < numCards[currUserId]; i++) {
                opposingPlayerContainer.appendChild(getCard("back", false));
            }
        }
    }

    function updatePlayerStats() {
        // Update the player stats screen to the left
        // At the beginning of the game, dont show the internal "-1" cards, thats ugly
        playerContainer.innerHTML = "";
        for (let [id, uname] of Object.entries(idToUserName)) {
            let p = document.createElement("p");
            if (currUserId == -1) {
                p.innerText = `${uname}`;
            } else if (currUserId == id) {
                p.innerHTML = `<b>${uname}: ${numCards[id]}</b>`;
            } else {
                p.innerText = `${uname}: ${numCards[id]}`;
            }
            playerContainer.appendChild(p);
        }
    }

    function cardCanBePlayed(card) {
        // Check if new_card can be played on this game
        if (myId != currUserId) {
            // Its not your turn
            return false;
        }

        let room_card = currentCardContainer.firstChild.name;
        [room_suit, room_val] = room_card;
        [card_suit, card_val] = card;
        
        if (p2_value == 0 && p4_value == 0) {
            // Standard gameflow
            if (card_suit == "w") {
                return true;
            }
            
            return room_suit == card_suit || room_val == card_val;
        }
        
        if (p2_value > 0) {
            // A +2 is in action
            if (p2_allow_foreign) {
                return Set("r", "+", "s").includes(card_val);
            } else {
                return card_val == "+";
            }
        }
            
        if (p4_value > 0) {
            // A +4 is in action
            if (p4_allow_foreign) {
                return Set("r", "p", "s").includes(card_val);
            } else {
                return card_val == "p";
            }
        }

        return false;
    }

    function changeCardStatuses() {
        // Change the status of each card, darken it if we cant play it
        let cards = cardContainer.children;
        for (c of cards) {
            if (!c.name || cardCanBePlayed(c.name)) {
                c.classList.remove("dark");
            } else {
                c.classList.add("dark");
            }
        }

        if (myId == currUserId) {
            baseCard.classList.remove("dark");
        } else {
            baseCard.classList.add("dark");
        }
    }

    function handleServerMsg(msg) {
        if (msg.startsWith("CARDS:")) {
            // The rest of the string is our cards. 
            let cards = JSON.parse(msg.substring(6));
            for (var i = 0; i < cards.length; i++) {
                let card = getCard(cards[i], true);
                addCard(card);
                opposingPlayerContainer.appendChild(getCard("back", false));
            }

            // Loop through each numCards element, and set their cards to the number of cards we got
            for (var id in numCards) {
                numCards[id] = cards.length;
            }

        } else if (msg.startsWith("CARD:")) {
            // The current card was changed
            let cardName = msg.substring(5);
            let card = getCard(cardName, false);
            currentCardContainer.innerHTML = "";
            currentCardContainer.appendChild(card);

            if (cardName.endsWith("+")) {
                // +2
                p2_value += 2
            } else if (cardName.endsWith("p")) {
                // +4
                p4_value += 4
            }

            // Decrement the current user's count, if the game is active
            // (Dont decrement count if this card is the starting card)
            // Also, dont decrement if the card is virtual (a colored wild card)
            if (currUserId != -1 && !["yw", "gw", "bw", "rw", "yp", "gp", "bp", "rp"].includes(cardName)) {
                numCards[currUserId] -= 1;
            }
        } else if (msg.startsWith("DRAW:")) {
            // The rest of the string is a list of cards we draw
            let cards = JSON.parse(msg.substring(5));
            for (var i = 0; i < cards.length; i++) {
                let card = getCard(cards[i], true);
                addCard(card);
            }

            // Add the number of drawn cards to the count keeper
            numCards[myId] += cards.length;

            // Update the card statuses just in cast these are dark
            changeCardStatuses();

            // After drawing, user can pass
            // FIXME is that true after +2 or +4?
            pass.style.visibility = "visible";

            // User drew cards, any +2 or +4 values are gone
            p2_value = 0; p4_value = 0;
        } else if (msg.startsWith("START")) {
            // Game started, replace Start Game button with Draw Card
            baseCard.removeEventListener("click", startGame);
            baseCard.src = "{{url_for('static', filename='UnoCards/DrawBack.png')}}";
            baseCard.addEventListener("click", () => {
                broadcast("draw").then((response) => {
                    if (!response.ok) {
                        // There was a 404! Print it to the console
                        console.log("Error when drawing card: 404");
                    }
                })
            });
        } else if (msg.startsWith("TURN:")) {
            // FIXME here we will check if its my turn etc
            // Hide the pass option
            pass.style.visibility = "hidden";
            currUserId = parseInt(msg.substring(5));

            changeCardStatuses();

        } else if (msg.startsWith("USER:")) {
            // Theres a new user, save their number of cards
            // Here, we save number of cards as -1, they will be overwritten when we get our cards
            let [uname, id] = msg.substring(5).split("/");
            idToUserName[id] = uname;
            numCards[id] = -1;
        } else if (msg.startsWith("DREW:")) {
            // Add the number of drawn cards to the user's count
            numCards[currUserId] += parseInt(msg.substring(5));
        } else {
            // Just print the message
            console.log(msg);
        }

        // Update the opposing player view, if its not my turn (keep previous player up otherwise)
        if (currUserId != myId) {
            updateOpposingPlayerWindow();
        }

        // Update the player stats to the left
        updatePlayerStats();
    }

    function checkForUpdate() {
        // Ping the server for an update
        // If there are updates, loop every .5 seconds updating as we go
        fetch('{{url_for("broadcast_hub", room_name=room_name)}}')
            .then((response) => response.text().then((text) => {
                let msgs = JSON.parse(text);
                for (var i = 0; i < msgs.length; i++) {
                    let msg = msgs[i];
                    handleServerMsg(msg);
                }
        }));
    }

    function delayLoop(func, time) {
        // Call func every time ms, waiting for func to complete before starting the next timer
        func();
        setTimeout(delayLoop, time, func, time);
    }

    // Check for game updates every .5 seconds
    delayLoop(checkForUpdate, 500);

    async function broadcast(msg) {
        // Send a message to the server
        return fetch('{{url_for("user_broadcast", room_name=room_name, msg="PLACE_MESSAGE_HERE")}}'.replace("PLACE_MESSAGE_HERE", encodeURIComponent(msg)));
    }

    // Here, we create base card. Base card is the start game button, and then the draw card button
    let baseCard = getCard("StartBack", false);
    deckContainer.appendChild(baseCard);

    // Start the game when we click on the base card (this is overridden in the START listener)
    baseCard.addEventListener("click", startGame);
    baseCard.style.cursor = "pointer";
</script>